% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SearchInstance.R
\name{SearchInstance}
\alias{SearchInstance}
\title{Search Instance}
\arguments{
\item{objective}{(\link[bbotk:Objective]{bbotk::Objective})\cr
The objective to evaluate. Can be any bbotk Objective subclass including
our ObjectiveDataset and ObjectiveLearner.}

\item{search_space}{(\link[paradox:ParamSet]{paradox::ParamSet})\cr
Optional restricted search space. If NULL:
\itemize{
\item If the domain contains no TuneTokens, uses the whole domain
\item If the domain contains TuneTokens, derives search space from them
Cannot be supplied if the domain already contains TuneTokens.
}}

\item{terminator}{(\link[bbotk:Terminator]{bbotk::Terminator})\cr
When to stop the search. Uses bbotk terminators.}

\item{archive}{(\link[bbotk:ArchiveBatch]{bbotk::ArchiveBatch})\cr
Optional pre-existing archive. If NULL, creates a new one.}

\item{check_values}{(\code{logical(1)})\cr
Whether to validate points against search_space before evaluation.}

\item{callbacks}{(\code{list()} of \link[mlr3misc:Callback]{mlr3misc::Callback})\cr
Optional callbacks to hook into the evaluation loop.}

\item{xdt}{(\code{data.table})\cr
Points to evaluate, one row per configuration.}

\item{...}{(ignored).}
}
\value{
Invisibly returns the ydt (codomain values).
}
\description{
Container for a search problem that extends bbotk's \link[bbotk:EvalInstance]{bbotk::EvalInstance} to support
both optimization and active learning. Holds the objective, search space,
archive, and terminator, and provides the evaluation loop mechanics.

Unlike \link[bbotk:OptimInstance]{bbotk::OptimInstance}, this class:
\itemize{
\item Supports codomains with "learn" tags (in addition to minimize/maximize)
\item Does not compute \code{objective_multiplicator}
\item Does not assign a "result" (best point)
}

Creates a new SearchInstance.

Evaluates a batch of points and adds results to the archive.

Resets the instance for a fresh search.

Printer.
}
\details{
The search instance serves as the "problem specification" for custom search
loops. It owns the archive and handles evaluation mechanics.

If you want to run a full MBO-style loop, prefer using bbotk's
\link[bbotk:OptimInstanceBatchSingleCrit]{bbotk::OptimInstanceBatchSingleCrit} / \link[bbotk:OptimInstanceBatchMultiCrit]{bbotk::OptimInstanceBatchMultiCrit}
together with \link[mlr3mbo:mlr_optimizers_mbo]{mlr3mbo::OptimizerMbo}. For codomains containing \code{"learn"}
targets, use \link{ResultAssignerNull} to disable assigning a "best" result.

Since bbotk's Codomain now natively supports "learn" tags, codomains are
passed directly to ArchiveBatch without conversion. Note that calling
\code{archive$best()} or \code{archive$nds_selection()} will error if the codomain
contains only "learn" targets, which is the correct behavior.
}
\section{Callbacks}{

Callbacks can be registered to hook into the evaluation loop. The following
stages are supported:
\itemize{
\item \code{on_optimizer_before_eval}: Called before evaluating a batch
\item \code{on_optimizer_after_eval}: Called after evaluating a batch
}
}

\section{Termination}{

Before each batch evaluation, the terminator is checked. If terminated, a
\code{search_terminated_error} condition is raised. This can be caught with
\code{tryCatch(..., search_terminated_error = function(e) ...)}.
}

